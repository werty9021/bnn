-- Module generated by TTA Codesign Environment
-- 
-- Generated on Thu Sep 19 16:08:44 2019
-- 
-- Function Unit: DBG
-- 
-- Operations:
--  ecc : 0
--  lcc : 1
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

entity fu_dbg is
  port (
    clk : in std_logic;
    rstx : in std_logic;
    glock_in : in std_logic;
    glockreq_out : out std_logic;
    operation_in : in std_logic_vector(1-1 downto 0);
    data_in1t_in : in std_logic_vector(32-1 downto 0);
    load_in1t_in : in std_logic;
    data_out1_out : out std_logic_vector(32-1 downto 0);
    debug_lock_count_in : in std_logic_vector(64-1 downto 0);
    debug_cycle_count_in : in std_logic_vector(64-1 downto 0));
end entity fu_dbg;

architecture rtl of fu_dbg is

  constant op_ecc_c : std_logic_vector(0 downto 0) := "0";
  constant op_lcc_c : std_logic_vector(0 downto 0) := "1";

  signal ecc_op1 : std_logic_vector(31 downto 0);
  signal ecc_op2 : std_logic_vector(31 downto 0);
  signal lcc_op1 : std_logic_vector(31 downto 0);
  signal lcc_op2 : std_logic_vector(31 downto 0);
  signal data_in1t : std_logic_vector(31 downto 0);
  signal data_out1 : std_logic_vector(31 downto 0);

  signal operation_1_r : std_logic_vector(0 downto 0);
  signal optrig_1_r : std_logic;
  signal data_out1_1_r : std_logic_vector(31 downto 0);
  signal data_out1_1_valid_r : std_logic;
  signal data_out1_r : std_logic_vector(31 downto 0);

begin

  data_in1t <= data_in1t_in;

  input_pipeline_sp : process(clk)
  begin
    if clk = '1' and clk'event then
      if rstx = '0' then
        operation_1_r <= (others => '0');
        optrig_1_r <= '0';
      else
        if (glock_in = '0') then
          optrig_1_r <= load_in1t_in;
          if (load_in1t_in = '1') then
            operation_1_r <= operation_in;
          end if;
        end if;
      end if;
    end if;
  end process input_pipeline_sp;

  operations_actual_cp : process(load_in1t_in, debug_lock_count_in, debug_cycle_count_in, lcc_op1, operation_in, ecc_op1, data_in1t)
  begin
    lcc_op2 <= (others => '-');
    lcc_op1 <= data_in1t;
    ecc_op2 <= (others => '-');
    ecc_op1 <= data_in1t;
    if (load_in1t_in = '1') then
      case operation_in is
        when op_ecc_c =>
          ecc_op2 <= debug_cycle_count_in(32-1 downto 0);
        when op_lcc_c =>
          lcc_op2 <= debug_lock_count_in(32-1 downto 0);
        when others =>
      end case;
    end if;
  end process operations_actual_cp;

  output_pipeline_sp : process(clk)
  begin
    if clk = '1' and clk'event then
      if rstx = '0' then
        data_out1_r <= (others => '0');
        data_out1_1_valid_r <= '0';
        data_out1_1_r <= (others => '0');
      else
        if (glock_in = '0') then
          data_out1_1_valid_r <= '1';
          if ((operation_in = op_lcc_c) and (load_in1t_in = '1')) then
            data_out1_1_r <= lcc_op2;
          elsif ((operation_in = op_ecc_c) and (load_in1t_in = '1')) then
            data_out1_1_r <= ecc_op2;
          else
            data_out1_1_valid_r <= '0';
          end if;
          data_out1_r <= data_out1;
        end if;
      end if;
    end if;
  end process output_pipeline_sp;

  output_pipeline_cp : process(data_out1, data_out1_r, data_out1_1_valid_r, data_out1_1_r)
  begin
    if (data_out1_1_valid_r = '1') then
      data_out1 <= data_out1_1_r;
    else
      data_out1 <= data_out1_r;
    end if;
    data_out1_out <= data_out1;
  end process output_pipeline_cp;
  glockreq_out <= '0';

end architecture rtl;

