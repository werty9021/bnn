-- Module generated by TTA Codesign Environment
-- 
-- Generated on Thu Sep 19 16:08:44 2019
-- 
-- Function Unit: vOPS
-- 
-- Operations:
--  extractelem16x32 : 0
--  ge32x32to32x1    : 1
--  geu16x32to32x1   : 2
--  insertelem16x32  : 3
--  max16x32         : 4
--  shlsame16x32     : 5
--  truncwh32x32     : 6
--  vbcast16x32      : 7
--  vreduce32x32     : 8
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

entity fu_vops is
  port (
    clk : in std_logic;
    rstx : in std_logic;
    glock_in : in std_logic;
    glockreq_out : out std_logic;
    operation_in : in std_logic_vector(4-1 downto 0);
    data_in1t_in : in std_logic_vector(1024-1 downto 0);
    load_in1t_in : in std_logic;
    data_in2_in : in std_logic_vector(1024-1 downto 0);
    load_in2_in : in std_logic;
    data_in3_in : in std_logic_vector(32-1 downto 0);
    load_in3_in : in std_logic;
    data_out1_out : out std_logic_vector(1024-1 downto 0));
end entity fu_vops;

architecture rtl of fu_vops is

  constant op_extractelem16x32_c : std_logic_vector(3 downto 0) := "0000";
  constant op_ge32x32to32x1_c : std_logic_vector(3 downto 0) := "0001";
  constant op_geu16x32to32x1_c : std_logic_vector(3 downto 0) := "0010";
  constant op_insertelem16x32_c : std_logic_vector(3 downto 0) := "0011";
  constant op_max16x32_c : std_logic_vector(3 downto 0) := "0100";
  constant op_shlsame16x32_c : std_logic_vector(3 downto 0) := "0101";
  constant op_truncwh32x32_c : std_logic_vector(3 downto 0) := "0110";
  constant op_vbcast16x32_c : std_logic_vector(3 downto 0) := "0111";
  constant op_vreduce32x32_c : std_logic_vector(3 downto 0) := "1000";

  signal extractelem16x32_op1 : std_logic_vector(511 downto 0);
  signal extractelem16x32_op2 : std_logic_vector(31 downto 0);
  signal extractelem16x32_op3 : std_logic_vector(15 downto 0);
  signal ge32x32to32x1_op1 : std_logic_vector(1023 downto 0);
  signal ge32x32to32x1_op2 : std_logic_vector(1023 downto 0);
  signal ge32x32to32x1_op3 : std_logic_vector(31 downto 0);
  signal geu16x32to32x1_op1 : std_logic_vector(511 downto 0);
  signal geu16x32to32x1_op2 : std_logic_vector(511 downto 0);
  signal geu16x32to32x1_op3 : std_logic_vector(31 downto 0);
  signal insertelem16x32_op1 : std_logic_vector(511 downto 0);
  signal insertelem16x32_op2 : std_logic_vector(15 downto 0);
  signal insertelem16x32_op3 : std_logic_vector(31 downto 0);
  signal insertelem16x32_op4 : std_logic_vector(511 downto 0);
  signal max16x32_op1 : std_logic_vector(511 downto 0);
  signal max16x32_op2 : std_logic_vector(511 downto 0);
  signal max16x32_op3 : std_logic_vector(511 downto 0);
  signal shlsame16x32_op1 : std_logic_vector(511 downto 0);
  signal shlsame16x32_op2 : std_logic_vector(15 downto 0);
  signal shlsame16x32_op3 : std_logic_vector(511 downto 0);
  signal truncwh32x32_op1 : std_logic_vector(1023 downto 0);
  signal truncwh32x32_op2 : std_logic_vector(511 downto 0);
  signal vbcast16x32_op1 : std_logic_vector(15 downto 0);
  signal vbcast16x32_op2 : std_logic_vector(511 downto 0);
  signal vreduce32x32_op1 : std_logic_vector(1023 downto 0);
  signal vreduce32x32_op2 : std_logic_vector(31 downto 0);
  signal data_in1t : std_logic_vector(1023 downto 0);
  signal data_in2 : std_logic_vector(1023 downto 0);
  signal data_in3 : std_logic_vector(31 downto 0);
  signal data_out1 : std_logic_vector(1023 downto 0);

  signal shadow_in2_r : std_logic_vector(1023 downto 0);
  signal shadow_in3_r : std_logic_vector(31 downto 0);
  signal operation_1_r : std_logic_vector(3 downto 0);
  signal optrig_1_r : std_logic;
  signal data_out1_1_r : std_logic_vector(1023 downto 0);
  signal data_out1_1_valid_r : std_logic;
  signal data_out1_r : std_logic_vector(1023 downto 0);

begin

  data_in1t <= data_in1t_in;

  shadow_in2_sp : process(clk)
  begin
    if clk = '1' and clk'event then
      if rstx = '0' then
        shadow_in2_r <= (others => '0');
      else
        if ((glock_in = '0') and (load_in2_in = '1')) then
          shadow_in2_r <= data_in2_in;
        end if;
      end if;
    end if;
  end process shadow_in2_sp;

  shadow_in2_cp : process(shadow_in2_r, load_in1t_in, data_in2_in, load_in2_in)
  begin
    if ((load_in1t_in = '1') and (load_in2_in = '1')) then
      data_in2 <= data_in2_in;
    else
      data_in2 <= shadow_in2_r;
    end if;
  end process shadow_in2_cp;

  shadow_in3_sp : process(clk)
  begin
    if clk = '1' and clk'event then
      if rstx = '0' then
        shadow_in3_r <= (others => '0');
      else
        if ((glock_in = '0') and (load_in3_in = '1')) then
          shadow_in3_r <= data_in3_in;
        end if;
      end if;
    end if;
  end process shadow_in3_sp;

  shadow_in3_cp : process(shadow_in3_r, data_in3_in, load_in1t_in, load_in3_in)
  begin
    if ((load_in1t_in = '1') and (load_in3_in = '1')) then
      data_in3 <= data_in3_in;
    else
      data_in3 <= shadow_in3_r;
    end if;
  end process shadow_in3_cp;

  input_pipeline_sp : process(clk)
  begin
    if clk = '1' and clk'event then
      if rstx = '0' then
        operation_1_r <= (others => '0');
        optrig_1_r <= '0';
      else
        if (glock_in = '0') then
          optrig_1_r <= load_in1t_in;
          if (load_in1t_in = '1') then
            operation_1_r <= operation_in;
          end if;
        end if;
      end if;
    end if;
  end process input_pipeline_sp;

  operations_actual_cp : process(load_in1t_in, data_in2, insertelem16x32_op3, insertelem16x32_op2, insertelem16x32_op1, max16x32_op1, data_in1t, geu16x32to32x1_op2, shlsame16x32_op2, data_in3, truncwh32x32_op1, max16x32_op2, geu16x32to32x1_op1, ge32x32to32x1_op2, vbcast16x32_op1, vreduce32x32_op1, ge32x32to32x1_op1, operation_in, extractelem16x32_op1, shlsame16x32_op1, extractelem16x32_op2)
    variable vreduce32x32_sum : signed(32-1 downto 0);
  begin
    vbcast16x32_op2 <= (others => '-');
    vbcast16x32_op1 <= data_in1t(15 downto 0);
    vreduce32x32_op2 <= (others => '-');
    vreduce32x32_op1 <= data_in1t;
    vreduce32x32_sum := (others => '-');
    truncwh32x32_op2 <= (others => '-');
    truncwh32x32_op1 <= data_in1t;
    shlsame16x32_op3 <= (others => '-');
    shlsame16x32_op1 <= data_in1t(511 downto 0);
    shlsame16x32_op2 <= data_in2(15 downto 0);
    ge32x32to32x1_op3 <= (others => '-');
    ge32x32to32x1_op1 <= data_in1t;
    ge32x32to32x1_op2 <= data_in2;
    extractelem16x32_op3 <= (others => '-');
    extractelem16x32_op1 <= data_in1t(511 downto 0);
    extractelem16x32_op2 <= data_in2(31 downto 0);
    geu16x32to32x1_op3 <= (others => '-');
    geu16x32to32x1_op1 <= data_in1t(511 downto 0);
    geu16x32to32x1_op2 <= data_in2(511 downto 0);
    max16x32_op3 <= (others => '-');
    max16x32_op1 <= data_in1t(511 downto 0);
    max16x32_op2 <= data_in2(511 downto 0);
    insertelem16x32_op4 <= (others => '-');
    insertelem16x32_op1 <= data_in1t(511 downto 0);
    insertelem16x32_op2 <= data_in2(15 downto 0);
    insertelem16x32_op3 <= data_in3;
    if (load_in1t_in = '1') then
      case operation_in is
        when op_extractelem16x32_c =>
          extractelem16x32_op3 <= extractelem16x32_op1(to_integer(unsigned(extractelem16x32_op2(4 downto 0)))*16+16-1 downto to_integer(unsigned(extractelem16x32_op2(4 downto 0)))*16);
        when op_ge32x32to32x1_c =>
          for i in 0 to 31 loop
            if signed(ge32x32to32x1_op1((i+1)*32-1 downto i*32)) >= signed(ge32x32to32x1_op2((i+1)*32-1 downto i*32)) then
              ge32x32to32x1_op3(31-i) <= '1';
            else
              ge32x32to32x1_op3(31-i) <= '0';
            end if;
          end loop;
        when op_geu16x32to32x1_c =>
          for i in 0 to 31 loop
            if unsigned(geu16x32to32x1_op1((i+1)*16-1 downto i*16)) >= unsigned(geu16x32to32x1_op2((i+1)*16-1 downto i*16)) then
              geu16x32to32x1_op3(31-i) <= '1';
            else
              geu16x32to32x1_op3(31-i) <= '0';
            end if;
          end loop;
        when op_insertelem16x32_c =>
          for i in 0 to 31 loop
            if(i = to_integer(unsigned(insertelem16x32_op3(4 downto 0)))) then
              insertelem16x32_op4((i+1)*16-1 downto i*16) <= insertelem16x32_op2(15 downto 0);
            else
              insertelem16x32_op4((i+1)*16-1 downto i*16) <= insertelem16x32_op1((i+1)*16-1 downto i*16);
            end if;
          end loop;
        when op_max16x32_c =>
          for i in 0 to 31 loop
            if signed(max16x32_op1((i+1)*16-1 downto i*16)) > signed(max16x32_op2((i+1)*16-1 downto i*16)) then
              max16x32_op3((i+1)*16-1 downto i*16) <= max16x32_op1((i+1)*16-1 downto i*16);
            else
              max16x32_op3((i+1)*16-1 downto i*16) <= max16x32_op2((i+1)*16-1 downto i*16);
            end if;
          end loop;
        when op_shlsame16x32_c =>
          for i in 0 to 31 loop
            shlsame16x32_op3((i+1)*16-1 downto i*16) <= std_logic_vector(shift_left(unsigned(shlsame16x32_op1((i+1)*16-1 downto i*16)), to_integer(unsigned(shlsame16x32_op2(3 downto 0)))));
          end loop;
        when op_truncwh32x32_c =>
          for i in 0 to 31 loop
            truncwh32x32_op2((i+1)*16-1 downto i*16) <= truncwh32x32_op1((i+1)*32-17 downto i*32);
          end loop;
        when op_vbcast16x32_c =>
          vbcast16x32_op2 <= vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 &
                 vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 &
                 vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 &
                 vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1 & vbcast16x32_op1;
        when op_vreduce32x32_c =>
          for i in 0 to 31 loop
            if (i = 0) then
              vreduce32x32_sum := signed(vreduce32x32_op1((i+1)*32-1 downto i*32));  
            else
              vreduce32x32_sum := vreduce32x32_sum + signed(vreduce32x32_op1((i+1)*32-1 downto i*32));
            end if;
          end loop;
          vreduce32x32_op2 <= std_logic_vector(vreduce32x32_sum);
        when others =>
      end case;
    end if;
  end process operations_actual_cp;

  output_pipeline_sp : process(clk)
  begin
    if clk = '1' and clk'event then
      if rstx = '0' then
        data_out1_r <= (others => '0');
        data_out1_1_valid_r <= '0';
        data_out1_1_r <= (others => '0');
      else
        if (glock_in = '0') then
          data_out1_1_valid_r <= '1';
          if ((operation_in = op_vreduce32x32_c) and (load_in1t_in = '1')) then
            data_out1_1_r <= ((1024-1 downto 32 => '0') & vreduce32x32_op2);
          elsif ((operation_in = op_vbcast16x32_c) and (load_in1t_in = '1')) then
            data_out1_1_r <= ((1024-1 downto 512 => '0') & vbcast16x32_op2);
          elsif ((operation_in = op_truncwh32x32_c) and (load_in1t_in = '1')) then
            data_out1_1_r <= ((1024-1 downto 512 => '0') & truncwh32x32_op2);
          elsif ((operation_in = op_shlsame16x32_c) and (load_in1t_in = '1')) then
            data_out1_1_r <= ((1024-1 downto 512 => '0') & shlsame16x32_op3);
          elsif ((operation_in = op_max16x32_c) and (load_in1t_in = '1')) then
            data_out1_1_r <= ((1024-1 downto 512 => '0') & max16x32_op3);
          elsif ((operation_in = op_insertelem16x32_c) and (load_in1t_in = '1')) then
            data_out1_1_r <= ((1024-1 downto 512 => '0') & insertelem16x32_op4);
          elsif ((operation_in = op_geu16x32to32x1_c) and (load_in1t_in = '1')) then
            data_out1_1_r <= ((1024-1 downto 32 => '0') & geu16x32to32x1_op3);
          elsif ((operation_in = op_ge32x32to32x1_c) and (load_in1t_in = '1')) then
            data_out1_1_r <= ((1024-1 downto 32 => '0') & ge32x32to32x1_op3);
          elsif ((operation_in = op_extractelem16x32_c) and (load_in1t_in = '1')) then
            data_out1_1_r <= ((1024-1 downto 16 => '0') & extractelem16x32_op3);
          else
            data_out1_1_valid_r <= '0';
          end if;
          data_out1_r <= data_out1;
        end if;
      end if;
    end if;
  end process output_pipeline_sp;

  output_pipeline_cp : process(data_out1, data_out1_r, data_out1_1_valid_r, data_out1_1_r)
  begin
    if (data_out1_1_valid_r = '1') then
      data_out1 <= data_out1_1_r;
    else
      data_out1 <= data_out1_r;
    end if;
    data_out1_out <= data_out1;
  end process output_pipeline_cp;
  glockreq_out <= '0';

end architecture rtl;

