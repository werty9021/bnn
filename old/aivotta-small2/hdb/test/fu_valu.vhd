-- Module generated by TTA Codesign Environment
-- 
-- Generated on Fri Jul 19 19:28:11 2019
-- 
-- Function Unit: vALU
-- 
-- Operations:
--  ge32x32to32x1        :  0
--  geu16x32to32x1       :  1
--  insertelem16x32      :  2
--  insertelem32x32      :  3
--  mac16x32to32x32      :  4
--  max16x32             :  5
--  not1024              :  6
--  shlsame16x32         :  7
--  shlsame32x32         :  8
--  truncwh32x32         :  9
--  vreduce32x32         : 10
--  xnorpopcountacc32x32 : 11
--  xor1024              : 12
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

entity fu_valu is
  port (
    clk : in std_logic;
    rstx : in std_logic;
    glock_in : in std_logic;
    -- glockreq_out : out std_logic;
    operation_in : in std_logic_vector(4-1 downto 0);
    data_in1t_in : in std_logic_vector(1024-1 downto 0);
    load_in1t_in : in std_logic;
    data_in2_in : in std_logic_vector(1024-1 downto 0);
    load_in2_in : in std_logic;
    data_in3_in : in std_logic_vector(1024-1 downto 0);
    load_in3_in : in std_logic;
    data_out1_out : out std_logic_vector(1024-1 downto 0));
end entity fu_valu;

architecture rtl of fu_valu is
  constant op_ge32x32to32x1_c : std_logic_vector(3 downto 0) := "0000";
  constant op_geu16x32to32x1_c : std_logic_vector(3 downto 0) := "0001";
  constant op_insertelem16x32_c : std_logic_vector(3 downto 0) := "0010";
  constant op_insertelem32x32_c : std_logic_vector(3 downto 0) := "0011";
  constant op_mac16x32to32x32_c : std_logic_vector(3 downto 0) := "0100";
  constant op_max16x32_c : std_logic_vector(3 downto 0) := "0101";
  constant op_not1024_c : std_logic_vector(3 downto 0) := "0110";
  -- constant op_shlsame16x32_c : std_logic_vector(3 downto 0) := "0111";
  -- constant op_shlsame32x32_c : std_logic_vector(3 downto 0) := "1000";
  -- constant op_truncwh32x32_c : std_logic_vector(3 downto 0) := "1001";
  -- constant op_vreduce32x32_c : std_logic_vector(3 downto 0) := "1010";
  -- constant op_xnorpopcountacc32x32_c : std_logic_vector(3 downto 0) := "1011";
  -- constant op_xor1024_c : std_logic_vector(3 downto 0) := "1100";
  constant op_truncwh32x32_c : std_logic_vector(3 downto 0) := "0111";
  constant op_vreduce32x32_c : std_logic_vector(3 downto 0) := "1000";
  constant op_xnorpopcountacc32x32_c : std_logic_vector(3 downto 0) := "1001";
  constant op_xor1024_c : std_logic_vector(3 downto 0) := "1010";

  signal operation : std_logic_vector(3 downto 0);
  signal data_in1t : std_logic_vector(1023 downto 0);
  signal data_in2 : std_logic_vector(1023 downto 0);
  signal data_in3 : std_logic_vector(1023 downto 0);

  signal shadow_in2_r : std_logic_vector(1023 downto 0);
  signal shadow_in3_r : std_logic_vector(1023 downto 0);
  
  signal control : std_logic_vector(2 downto 0);

  -- signal data_out1_reg : std_logic_vector(1023 downto 0); --=data_out1_reg
  signal data_out1     : std_logic_vector(1023 downto 0); --=alle output ops
  signal trigger_out1 : std_ulogic; --=trigger vgm
begin
  
  control <= load_in2_in&load_in1t_in&load_in3_in;

  shadow_registers_sync : process(clk, rstx)
  begin
    if rstx = '0' then
      data_in1t  <= (others => '0');
      data_in2  <= (others => '0');
      data_in3  <= (others => '0');
      shadow_in2_r <= (others => '0');
      shadow_in3_r <= (others => '0');
      -- data_out1_reg  <= (others => '0');
      trigger_out1  <= '0';
    elsif rising_edge(clk) then
      if glock_in = '0' then
        case control is
          when "111" =>
            data_in2     <= data_in2_in;
            shadow_in2_r <= data_in2_in;
            --  putting to data_in3_in to data_in3's (rest are zeros by reset) 
            data_in3     <= data_in3_in;
            shadow_in3_r <= data_in3_in;
            data_in1t        <= data_in1t_in;

            operation <= operation_in;
          when "110" =>
            data_in2     <= data_in2_in;
            shadow_in2_r <= data_in2_in;
            data_in1t        <= data_in1t_in;

            operation <= operation_in;
          when "011" =>
            data_in3     <= data_in3_in;
            shadow_in3_r <= data_in3_in;
            data_in1t        <= data_in1t_in;

            operation <= operation_in;
          when "101" =>
            shadow_in2_r <= data_in2_in;
            shadow_in3_r <= data_in3_in;
          when "100" =>
            shadow_in2_r <= data_in2_in;
          when "001" =>
            shadow_in3_r <= data_in3_in;
          when "010" =>
            data_in2     <= shadow_in2_r;
            data_in3     <= shadow_in3_r;
            data_in1t    <= data_in1t_in;

            operation <= operation_in;
          when others => null;
        end case;

        -- update result only when new operation was triggered
        -- trigger_out1 <= load_in1t_in;

        -- if trigger_out1 = '1' then
        --   data_out1_reg <= data_out1;
        -- end if;
      end if;
    end if;
  end process;

  actual : process(data_in1t, data_in2, data_in3, operation) -- load_in1t_in,
    variable mac16x32to32x32_out_v : signed(32-1 downto 0);
    variable xnorpopcountacc32x32_xnor_result : std_logic_vector(1024-1 downto 0);
    variable xnorpopcountacc32x32_count : unsigned(16-1 downto 0);
    variable vreduce32x32_sum : signed(32-1 downto 0);

    -- type std_logic_vector_array is array (natural range <>) of std_logic_vector(15 downto 0);
    -- variable y_temp : std_logic_vector_array (0 to 4);
    variable y_temp : std_logic_vector(15 downto 0);
    variable j : integer range 0 to 15;
  begin
    -- data_out1 <= (others => '0'); --zelf

    -- mac16x32to32x32_out_v := (others => '-');
    -- vreduce32x32_sum := (others => '-');
    -- xnorpopcountacc32x32_xnor_result := (others => '-');
    -- xnorpopcountacc32x32_count := (others => '-');

    case operation is
      when op_ge32x32to32x1_c =>
        for i in 0 to 31 loop
          if signed(data_in1t((i+1)*32-1 downto i*32)) >= signed(data_in2((i+1)*32-1 downto i*32)) then
            data_out1(31-i) <= '1';
          else
            data_out1(31-i) <= '0';
          end if;
        end loop;

      when op_geu16x32to32x1_c =>
        for i in 0 to 31 loop
          if unsigned(data_in1t((i+1)*16-1 downto i*16)) >= unsigned(data_in2((i+1)*16-1 downto i*16)) then
            data_out1(31-i) <= '1';
          else
            data_out1(31-i) <= '0';
          end if;
        end loop;

      when op_insertelem16x32_c =>
        for i in 0 to 31 loop
          if(i = to_integer(unsigned(data_in3(4 downto 0)))) then
            data_out1((i+1)*16-1 downto i*16) <= data_in2(15 downto 0);
          else
            data_out1((i+1)*16-1 downto i*16) <= data_in1t((i+1)*16-1 downto i*16);
          end if;
        end loop;

      when op_insertelem32x32_c =>
        for i in 0 to 31 loop
          if(i = to_integer(unsigned(data_in3(4 downto 0)))) then
            data_out1((i+1)*32-1 downto i*32) <= data_in2(31 downto 0);
          else
            data_out1((i+1)*32-1 downto i*32) <= data_in1t((i+1)*32-1 downto i*32);
          end if;
        end loop;

      when op_mac16x32to32x32_c =>
        for i in 0 to 31 loop
          mac16x32to32x32_out_v := signed(data_in3((i+1)*32-1 downto i*32)) + signed(data_in1t((i+1)*16-1 downto i*16)) * signed(data_in2((i+1)*16-1 downto i*16));
          data_out1((i+1)*32-1 downto i*32) <= std_logic_vector(mac16x32to32x32_out_v);
        end loop;

      when op_max16x32_c =>
        for i in 0 to 31 loop
          if signed(data_in1t((i+1)*16-1 downto i*16)) > signed(data_in2((i+1)*16-1 downto i*16)) then
            data_out1((i+1)*16-1 downto i*16) <= data_in1t((i+1)*16-1 downto i*16);
          else
            data_out1((i+1)*16-1 downto i*16) <= data_in2((i+1)*16-1 downto i*16);
          end if;
        end loop;

      when op_not1024_c =>
        data_out1 <= not data_in1t;

      -- when op_shlsame16x32_c =>
      --   for i in 0 to 31 loop
          
      --     if (data_in2(1023 downto 4) /= (1019 downto 0 => '0') ) then
      --       data_out1((i+1)*16-1 downto i*16) <= (others => '0');
      --     else
      --       -- data_out1((i+1)*16-1 downto i*16) <= std_logic_vector(
      --       --     shift_left(unsigned(data_in1t((i+1)*16-1 downto i*16)), to_integer(unsigned(data_in2(3 downto 0))))
      --       --   );
      --       y_temp := data_in1t((i+1)*16-1 downto i*16);
      --       j:=0;
      --       while (j<to_integer(unsigned(data_in2(3 downto 0)))) loop
      --         y_temp := y_temp(14 downto 0) & '0';
      --         j:=j+1;
      --       end loop;
      --       data_out1((i+1)*16-1 downto i*16) <= y_temp;
      --     end if;
      --   end loop;


      --   -- for j in 0 to 31 loop
      --   --   y_temp(0) := data_in1t((j+1)*16-1 downto j*16);
      --   --   for i in 0 to 3 loop
      --   --     if (data_in2(j*16 + i) = '1') then
      --   --       y_temp(i+1) := (others => '0');
      --   --       y_temp(i+1)(15 downto 2**i) := y_temp(i)(15-2**i downto 0);
      --   --     else
      --   --       y_temp(i+1) := y_temp(i);
      --   --     end if;
      --   --   end loop;
      --   -- data_out1((j+1)*16-1 downto j*16) <= y_temp(4);
      --   -- end loop;

      -- when op_shlsame32x32_c =>
      --   for i in 0 to 31 loop
      --     data_out1((i+1)*32-1 downto i*32) <= std_logic_vector(shift_left(unsigned(data_in1t((i+1)*32-1 downto i*32)), to_integer(unsigned(data_in2(4 downto 0)))));
      --   end loop;

      when op_truncwh32x32_c =>
        for i in 0 to 31 loop
          data_out1((i+1)*16-1 downto i*16) <= data_in1t((i+1)*32-17 downto i*32);
        end loop;

      when op_vreduce32x32_c =>
        for i in 0 to 31 loop
          if (i = 0) then
            vreduce32x32_sum := signed(data_in1t((i+1)*32-1 downto i*32));  
          else
            vreduce32x32_sum := vreduce32x32_sum + signed(data_in1t((i+1)*32-1 downto i*32));
          end if;
        end loop;
        data_out1 <= ((1023 downto 32 => '0' ) & std_logic_vector(vreduce32x32_sum));

      when op_xnorpopcountacc32x32_c =>
        xnorpopcountacc32x32_xnor_result := data_in1t xnor data_in2;
        for i in 0 to 31 loop
          xnorpopcountacc32x32_count := unsigned(data_in3((i+1)*16-1 downto i*16));
          for j in 0 to 31 loop
            if(xnorpopcountacc32x32_xnor_result(i*32 + j) = '1') then
              xnorpopcountacc32x32_count := xnorpopcountacc32x32_count + 1;
            end if;
          end loop;
          
          data_out1((i+1)*16-1 downto i*16) <= std_logic_vector(xnorpopcountacc32x32_count);
        end loop;

      when op_xor1024_c =>
        data_out1 <= data_in1t xor data_in2;

      when others => null;
    end case;
  end process actual;

  -- data_out1_out <= data_out1_reg;
  data_out1_out <= data_out1;
  -- glockreq_out <= '0';

end architecture rtl;
